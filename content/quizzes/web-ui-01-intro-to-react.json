{
  "quizName": "Intro to React",
  "questions": [
    {
      "id": "q1",
      "question": "What is React's primary purpose?",
      "options": [
        "A database management system",
        "A JavaScript library for building user interfaces",
        "A server-side framework",
        "A styling framework"
      ],
      "correct": 1,
      "explanation": "React is a JavaScript library specifically designed for building user interfaces, particularly for web applications. It focuses on creating reusable components and efficiently updating the DOM."
    },
    {
      "id": "q2",
      "question": "What does JSX stand for and what is its purpose?",
      "options": [
        "JavaScript XML - it allows you to write HTML-like syntax in JavaScript",
        "JavaScript Extension - it extends JavaScript with new keywords",
        "JSON XML - it converts JSON to XML",
        "JavaScript Syntax - it's a new JavaScript syntax standard"
      ],
      "correct": 0,
      "explanation": "JSX stands for JavaScript XML. It's a syntax extension that lets you write HTML-like code in JavaScript, making React components more readable and intuitive. JSX gets compiled to `React.createElement()` calls."
    },
    {
      "id": "q3",
      "question": "Consider the following code snippet:\n\n```tsx\nfunction Greeting({ name }: { name: string }) {\n  return (\n    <div className=\"greeting\">\n      <h1>Hello, {name}!</h1>\n    </div>\n  );\n}\n```\n\nWhy is `className` used instead of `class`?",
      "options": [
        "`class` is a reserved word in JavaScript, so React uses `className` instead",
        "`className` is faster to process",
        "`class` doesn't work in React",
        "`className` is required by TypeScript"
      ],
      "correct": 0,
      "explanation": "Since `class` is a reserved word in JavaScript (used for ES6 classes), React uses `className` instead to avoid conflicts. This is one of the key JSX rules - use `className` instead of `class` for CSS classes."
    },
    {
      "id": "q4",
      "question": "What is a React component?",
      "options": [
        "A database table",
        "A reusable piece of UI that returns JSX",
        "A JavaScript function that can't return anything",
        "A CSS styling rule"
      ],
      "correct": 1,
      "explanation": "A React component is a reusable piece of UI. It's like a function that returns JSX, allowing you to build complex interfaces by composing smaller, independent pieces together."
    },
    {
      "id": "q5",
      "question": "Consider the following code snippet:\n\n```tsx\nfunction App() {\n  return (\n    <div>\n      <Welcome />\n      <Welcome />\n      <Welcome />\n    </div>\n  );\n}\n```\n\nWhat does this demonstrate?",
      "options": [
        "Components can only be used once",
        "Components are reusable - you can use the same component multiple times",
        "This will cause an error",
        "Components must have unique names"
      ],
      "correct": 1,
      "explanation": "This demonstrates that components are reusable. You can use the same component (`Welcome`) multiple times in your application, and each instance is independent. This is one of React's key benefits - write once, use anywhere."
    },
    {
      "id": "q6",
      "question": "What are props in React?",
      "options": [
        "Internal component state",
        "Data passed from a parent component to a child component",
        "CSS properties",
        "JavaScript methods"
      ],
      "correct": 1,
      "explanation": "Props (short for \"properties\") are how you pass data from a parent component to a child component. Props are read-only - a component cannot modify its own props. They flow down the component tree."
    },
    {
      "id": "q7",
      "question": "Consider the following code snippet:\n\n```tsx\nfunction Greeting({ name, age }: { name: string; age: number }) {\n  return (\n    <div>\n      <h1>Hello, {name}!</h1>\n      <p>You are {age} years old</p>\n    </div>\n  );\n}\n\nfunction App() {\n  return <Greeting name=\"Alice\" age={25} />;\n}\n```\n\nWhat will be rendered?",
      "options": [
        "An error because props can't be passed this way",
        "\"Hello, Alice!\" and \"You are 25 years old\"",
        "Nothing - components don't render anything",
        "The component names"
      ],
      "correct": 1,
      "explanation": "The `App` component passes `name=\"Alice\"` and `age={25}` as props to `Greeting`. The `Greeting` component receives these props and renders \"Hello, Alice!\" and \"You are 25 years old\". Note that string props can be passed with quotes, while numbers and other expressions use curly braces."
    },
    {
      "id": "q8",
      "question": "Consider the following code snippet:\n\n```tsx\ninterface GreetingProps {\n  name: string;\n  age: number;\n  email?: string;\n}\n\nfunction Greeting({ name, age, email }: GreetingProps) {\n  return (\n    <div>\n      <h1>Hello, {name}!</h1>\n      <p>Age: {age}</p>\n      {email && <p>Email: {email}</p>}\n    </div>\n  );\n}\n```\n\nWhat does the `?` in `email?: string` mean?",
      "options": [
        "The email prop is required",
        "The email prop is optional - it may or may not be provided",
        "The email prop must be a string or number",
        "The email prop is deprecated"
      ],
      "correct": 1,
      "explanation": "The `?` in TypeScript makes a property optional. `email?: string` means the `email` prop is optional - the parent component may or may not provide it. The code uses `{email && <p>Email: {email}</p>}` to conditionally render the email only if it's provided."
    },
    {
      "id": "q9",
      "question": "What is the purpose of React hooks?",
      "options": [
        "To style components",
        "To hook into React features like state and lifecycle in functional components",
        "To create database connections",
        "To define CSS classes"
      ],
      "correct": 1,
      "explanation": "Hooks are functions that let you \"hook into\" React features like state and lifecycle. They always start with `use` (like `useState`, `useEffect`). Hooks allow functional components to have state and side effects, which were previously only available in class components."
    },
    {
      "id": "q10",
      "question": "Consider the following code snippet:\n\n```tsx\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  \n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>Click me</button>\n    </div>\n  );\n}\n```\n\nWhat does `useState(0)` return?",
      "options": [
        "Just the current count value",
        "An array with `[currentValue, setterFunction]`",
        "A number",
        "Nothing - it's a void function"
      ],
      "correct": 1,
      "explanation": "`useState(0)` returns an array with two elements: the current state value and a function to update it. The code uses array destructuring to get `count` (the current value) and `setCount` (the setter function). The `0` is the initial value."
    },
    {
      "id": "q11",
      "question": "Consider the following code snippet:\n\n```tsx\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  \n  const handleClick = () => {\n    setCount(count + 1);\n    console.log(count);\n  };\n  \n  return <button onClick={handleClick}>{count}</button>;\n}\n```\n\nWhat will be logged to the console when the button is clicked?",
      "options": [
        "The new count value (e.g., 1, 2, 3...)",
        "The old count value (e.g., 0, 1, 2...)",
        "An error",
        "Nothing"
      ],
      "correct": 1,
      "explanation": "State updates in React are asynchronous. When `setCount(count + 1)` is called, React schedules a state update, but the `count` variable in the current function execution still has the old value. The `console.log(count)` will log the old value. The state update and re-render happen after the function completes."
    },
    {
      "id": "q12",
      "question": "What happens when you call a state setter function like `setCount(5)`?",
      "options": [
        "The DOM is immediately updated",
        "React updates state in memory, schedules a re-render, compares Virtual DOMs, and updates only changed DOM nodes",
        "Nothing happens",
        "The component is deleted"
      ],
      "correct": 1,
      "explanation": "When you call `setCount(5)`, React: 1) Updates the state value in memory, 2) Schedules a re-render of the component, 3) Compares the new Virtual DOM with the previous one (diffing), 4) Updates only the specific DOM nodes that changed. This process is called \"reconciliation\" and makes React efficient."
    },
    {
      "id": "q13",
      "question": "Consider the following code snippet:\n\n```tsx\nfunction UserProfile({ userId }: { userId: number }) {\n  const [user, setUser] = useState(null);\n  \n  useEffect(() => {\n    async function fetchUser() {\n      const res = await fetch(`/api/users/${userId}`);\n      const data = await res.json();\n      setUser(data);\n    }\n    fetchUser();\n  }, [userId]);\n  \n  if (!user) return <div>Loading...</div>;\n  \n  return <div>{user.name}</div>;\n}\n```\n\nWhat does the `[userId]` dependency array do?",
      "options": [
        "It makes the effect run only once on mount",
        "It makes the effect run whenever `userId` changes",
        "It prevents the effect from running",
        "It makes the effect run on every render"
      ],
      "correct": 1,
      "explanation": "The dependency array `[userId]` tells React to re-run the effect whenever `userId` changes. If `userId` is 1, then changes to 2, the effect will run again to fetch the new user. Without the dependency array, the effect would run on every render. With an empty array `[]`, it would run only once on mount."
    },
    {
      "id": "q14",
      "question": "Consider the following code snippet:\n\n```tsx\nuseEffect(() => {\n  const timer = setInterval(() => {\n    console.log('Tick');\n  }, 1000);\n  \n  return () => {\n    clearInterval(timer);\n  };\n}, []);\n```\n\nWhat does the returned function do?",
      "options": [
        "It runs before the effect",
        "It's a cleanup function that runs when the component unmounts or before the effect re-runs",
        "It returns the timer value",
        "It's required for all effects"
      ],
      "correct": 1,
      "explanation": "The returned function is a cleanup function. It runs when the component unmounts or before the effect re-runs (if dependencies change). In this case, it clears the interval to prevent memory leaks. Cleanup functions are essential for subscriptions, timers, and event listeners."
    },
    {
      "id": "q15",
      "question": "What is React Context used for?",
      "options": [
        "Styling components",
        "Passing data through the component tree without prop drilling",
        "Making API calls",
        "Defining TypeScript types"
      ],
      "correct": 1,
      "explanation": "React Context provides a way to pass data through the component tree without having to pass props down manually at every level. It's useful for \"global\" data like themes, user authentication, or language preferences that many components need access to."
    },
    {
      "id": "q16",
      "question": "Consider the following code snippet:\n\n```tsx\nconst ThemeContext = createContext<ThemeContextType | undefined>(undefined);\n\nfunction App() {\n  const [theme, setTheme] = useState<'light' | 'dark'>('light');\n  \n  return (\n    <ThemeContext.Provider value={{ theme, toggleTheme }}>\n      <Header />\n    </ThemeContext.Provider>\n  );\n}\n\nfunction Header() {\n  const { theme } = useContext(ThemeContext)!;\n  return <header className={theme}>Header</header>;\n}\n```\n\nWhat does `ThemeContext.Provider` do?",
      "options": [
        "It creates the context",
        "It provides the context value to all child components",
        "It consumes the context",
        "It destroys the context"
      ],
      "correct": 1,
      "explanation": "`ThemeContext.Provider` wraps components and provides the context value to all child components. Any component inside the Provider (like `Header`) can access the context value using `useContext(ThemeContext)`. The `value` prop is what gets passed down to consumers."
    },
    {
      "id": "q17",
      "question": "Consider the following code snippet:\n\n```tsx\nfunction useTheme() {\n  const context = useContext(ThemeContext);\n  if (!context) {\n    throw new Error('useTheme must be used within ThemeProvider');\n  }\n  return context;\n}\n```\n\nWhy create a custom hook like this instead of using `useContext` directly?",
      "options": [
        "It's required by React",
        "It provides better error handling and makes the API cleaner",
        "It's faster",
        "It prevents re-renders"
      ],
      "correct": 1,
      "explanation": "Creating a custom hook like `useTheme` provides better error handling (throwing a clear error if used outside the Provider) and makes the API cleaner. Instead of using `useContext(ThemeContext)!` everywhere, components can just call `useTheme()`. It also centralizes the context access logic."
    },
    {
      "id": "q18",
      "question": "What does \"lifting state up\" mean in React?",
      "options": [
        "Moving state from a child component to a parent component so multiple children can share it",
        "Deleting state from a component",
        "Moving state to a database",
        "Making state global"
      ],
      "correct": 0,
      "explanation": "Lifting state up means moving state from a child component to a common parent component. This allows multiple child components to share the same state. The parent passes the state down as props, and callbacks to update it, to the children."
    },
    {
      "id": "q19",
      "question": "Consider the following code snippet:\n\n```tsx\nfunction Parent() {\n  const [count, setCount] = useState(0);\n  \n  return (\n    <div>\n      <Counter count={count} onIncrement={() => setCount(count + 1)} />\n      <Display count={count} />\n    </div>\n  );\n}\n```\n\nThis is an example of:",
      "options": [
        "Prop drilling",
        "Lifting state up - the parent manages state that multiple children need",
        "Context usage",
        "State management library"
      ],
      "correct": 1,
      "explanation": "This is an example of lifting state up. The `Parent` component manages the `count` state, and both `Counter` and `Display` children receive it as props. This allows them to share the same state. The parent also passes a callback (`onIncrement`) so the child can update the parent's state."
    },
    {
      "id": "q20",
      "question": "How do child components communicate with parent components?",
      "options": [
        "Through props only",
        "Through callbacks passed as props",
        "Through direct function calls",
        "Through global variables"
      ],
      "correct": 1,
      "explanation": "Child components communicate with parent components through callbacks passed as props. The parent passes a function (like `onIncrement`) to the child, and the child calls that function when it needs to notify the parent. This maintains React's unidirectional data flow."
    },
    {
      "id": "q21",
      "question": "Consider the following code snippet:\n\n```tsx\nfunction App() {\n  const [sharedData, setSharedData] = useState('');\n  \n  return (\n    <div>\n      <Input onUpdate={setSharedData} />\n      <Display data={sharedData} />\n    </div>\n  );\n}\n```\n\nHow do `Input` and `Display` communicate?",
      "options": [
        "Directly with each other",
        "Through the parent component - Input updates parent state, Display reads it",
        "Through Context",
        "They can't communicate"
      ],
      "correct": 1,
      "explanation": "Sibling components communicate through their common parent. `Input` calls `onUpdate` (which is `setSharedData`) to update the parent's state. `Display` receives `sharedData` as a prop. The parent acts as the intermediary, maintaining the state that both siblings need."
    },
    {
      "id": "q22",
      "question": "What is the Virtual DOM?",
      "options": [
        "A real DOM element",
        "A JavaScript representation of the DOM that React keeps in memory",
        "A database",
        "A CSS framework"
      ],
      "correct": 1,
      "explanation": "The Virtual DOM is a JavaScript representation of the DOM that React keeps in memory. When state changes, React creates a new Virtual DOM tree, compares it with the previous one (diffing), and then updates only the specific real DOM nodes that changed. This makes React efficient."
    },
    {
      "id": "q23",
      "question": "What is React's reconciliation process?",
      "options": [
        "The process of comparing Virtual DOMs and updating only changed DOM nodes",
        "The process of creating components",
        "The process of styling components",
        "The process of making API calls"
      ],
      "correct": 0,
      "explanation": "Reconciliation is React's process of comparing the new Virtual DOM with the previous one (called \"diffing\") and then updating only the specific real DOM nodes that changed. This is what makes React efficient - instead of re-rendering everything, React only updates what's necessary."
    },
    {
      "id": "q24",
      "question": "Consider the following code snippet:\n\n```tsx\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  \n  const handleClick = () => {\n    setCount(count + 1);\n    setCount(count + 1);\n    setCount(count + 1);\n  };\n  \n  return <button onClick={handleClick}>{count}</button>;\n}\n```\n\nIf the button is clicked once, what will the count be?",
      "options": [
        "3",
        "1",
        "0",
        "An error occurs"
      ],
      "correct": 1,
      "explanation": "The count will be 1, not 3. React batches state updates, and since all three `setCount` calls use the same `count` value (they're all based on the current state), they all set it to `count + 1` which is the same value. To increment by 3, you'd need to use the functional update form: `setCount(prev => prev + 1)` three times."
    },
    {
      "id": "q25",
      "question": "Consider the following code snippet:\n\n```tsx\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  \n  const handleClick = () => {\n    setCount(prev => prev + 1);\n    setCount(prev => prev + 1);\n    setCount(prev => prev + 1);\n  };\n  \n  return <button onClick={handleClick}>{count}</button>;\n}\n```\n\nIf the button is clicked once, what will the count be?",
      "options": [
        "3",
        "1",
        "0",
        "An error occurs"
      ],
      "correct": 0,
      "explanation": "The count will be 3. When you use the functional update form `setCount(prev => prev + 1)`, React passes the previous state value to the function. Each call receives the updated value from the previous call, so they chain together: 0 → 1 → 2 → 3. This is the correct way to update state based on previous state."
    },
    {
      "id": "q26",
      "question": "What is the difference between declarative and imperative programming in the context of React?",
      "options": [
        "Declarative describes what the UI should look like; imperative describes how to change it step-by-step",
        "They are the same thing",
        "Declarative is faster",
        "Imperative is required for React"
      ],
      "correct": 0,
      "explanation": "React is declarative - you describe what the UI should look like based on state, and React figures out how to update the DOM. Imperative programming (like vanilla JavaScript) requires you to manually manipulate the DOM step-by-step. React's declarative approach makes code more predictable and easier to reason about."
    },
    {
      "id": "q27",
      "question": "What happens if you call `setCount` with the same value that `count` already has?",
      "options": [
        "React always triggers a re-render",
        "React won't trigger a re-render (uses Object.is() comparison)",
        "An error occurs",
        "The component is deleted"
      ],
      "correct": 1,
      "explanation": "React uses `Object.is()` to compare the new state value with the current one. If they're the same, React won't trigger a re-render. This is an optimization - if nothing changed, there's no need to update the UI."
    }
  ]
}
